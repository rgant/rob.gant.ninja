---
import ArticleHeader from '~/components/article-header.astro';
import BaseHead from '~/components/base-head.astro';
import MySiteNav from '~/components/my-site-nav.astro';
import ScrollNavigation from '~/components/scroll-navigation.astro';
import Structure from '~/layouts/structure.astro';
import '~/styles/article-pages.css';
import { unwrap } from '~/scripts/server/unwrap.util';

const description = unwrap`How to deploy static websites with Terraform and AWS Amplify, including
  migration from S3/CloudFront, managing custom domains, and working around Terraform limitations.`;
---
<Structure>
  <BaseHead description={description} slot="head" title="Deploying Static Websites with Terraform and AWS Amplify" />

  <ArticleHeader currentPage="deploy.html">
    <h1 class="decorated-heading primary">Deploying Static Websites with Terraform</h1>
    <p>Using <abbr title="Amazon Web Services">AWS</abbr> Amplify for static site generator hosting</p>
  </ArticleHeader>

  <article class="presentation">
    <aside>
      <nav aria-labelledby="article-nav">
        <h3 id="article-nav">On this page</h3>
        <ScrollNavigation>
          <ul class="in-page-nav">
            <li><a href="#migration">From S3/CloudFront to Amplify</a></li>
            <li><a href="#terraform">Terraform configuration</a></li>
            <li><a href="#challenges">Challenges and workarounds</a></li>
            <li><a href="#security">Security considerations</a></li>
            <li><a href="#process">Deployment process</a></li>
            <li><a href="#monitoring">Monitoring and observability</a></li>
            <li><a href="#future">Future improvements</a></li>
          </ul>
        </ScrollNavigation>
      </nav>
    </aside>

    <section id="migration" class="slide">
      <h2 class="decorated-heading second">From S3/CloudFront to Amplify</h2>

      <ul class="key-points">
        <li>
          <strong>Directory Index Limitations:</strong>
          <a rel="noreferrer" href="https://aws.amazon.com/cloudfront/" target="_blank" title="AWS CloudFront">CloudFront’s</a> root object
          configuration only applies to the root domain, not subdirectories.
        </li>
        <li>
          <strong>S3 Website Hosting:</strong>
          A basic static file server that requires public
          <a rel="noreferrer" href="https://aws.amazon.com/s3/" target="_blank" title="AWS S3">S3</a>
          bucket access and complex CloudFront <abbr title="Content Delivery Network">CDN</abbr> configuration, introducing security
          exposure and operational complexity.
        </li>
        <li>
          <strong>AWS Amplify:</strong>
          Supports per-directory <code>index.html</code> files with integrated <abbr title="Secure Sockets Layer">SSL</abbr> certificate
          management, custom <abbr title="HyperText Transfer Protocol">HTTP</abbr> response headers, and CloudFront. I chose this solution
          for its static hosting capabilities.
        </li>
        <li>
          <strong>Migration Strategy:</strong>
          I tested
          <a rel="noreferrer" href="https://aws.amazon.com/amplify/" target="_blank" title="AWS Amplify">Amplify</a>
          by deploying to a separate domain before switching production domains to validate functionality and identify configuration issues.
        </li>
      </ul>

      <div class="description">
        <p>
          My initial website architecture used an
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/blob/965c74fdd00c25d212505d80f6f9916f515eaef5/infrastructure/website.tf"
            target="_blank"
          >S3 bucket as a CloudFront origin</a>, which functioned correctly for a single-page site. When expanding to multiple pages
          organized in directories, I required each directory to have its own <code>index.html</code> root object. I could have implemented
          a CloudFront Function to
          <a
            rel="noreferrer"
            href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/example_cloudfront_functions_url_rewrite_single_page_apps_section.html"
            target="_blank"
          >add <code>index.html</code> to the origin request <abbr title="Uniform Resource Identifier">URI</abbr></a>, but this approach
          would require maintaining custom CloudFront Functions while
          <a rel="noreferrer" href="https://aws.amazon.com/" target="_blank" title="Amazon Web Services">AWS</a>
          continues expanding Amplify’s static hosting features.
        </p>

        <p>
          S3 website hosting would have required making the bucket publicly accessible, introducing security exposure even for static
          content. CloudFront requires manual configuration of the S3 website endpoint for the origin, adding complexity compared to direct
          S3 bucket origins that are automatically populated by the AWS console interface. Custom response headers, redirects, and error
          page support is limited and can conflict with CloudFront configuration.
        </p>

        <p>
          AWS Amplify is the recommended solution for static website hosting on AWS. It offers support for directory-level
          <code>index.html</code> files, automatic configuration of Route53 <abbr title="Domain Name System">DNS</abbr> and SSL
          certificates, and URI pattern based customizable HTTP response headers. While Amplify is primarily marketed for single-page
          applications (SPAs), it works equally well for static site generators like
          <a rel="noreferrer" href="https://astro.build/" target="_blank">Astro</a>. Amplify uses CloudFront internally without exposing
          configuration options. The default CloudFront configuration appears reasonably strict, making this limitation acceptable for my
          security requirements.
        </p>

        <p>
          Before migrating the production site, I created a
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/tree/107dc465b922391d8317e0380cb36bc9f96fc00d/infrastructure/amplify"
            target="_blank"
          >test deployment</a>
          under a different domain to validate functionality. This allowed me to identify potential issues with domain configuration and
          content delivery before switching the main domain. Testing proved essential since configuring Amplify through
          <a rel="noreferrer" href="https://developer.hashicorp.com/terraform" target="_blank">Terraform</a>
          presented significant challenges. I needed to delete and recreate the test site multiple times to resolve issues with automatic
          SSL certificate generation, redirects, and custom headers.
        </p>
      </div>

      <div class="section-nav">
        <a href="#article-nav" class="top-link" title="Back to navigation">Top</a>
      </div>
    </section>

    <section id="terraform" class="slide">
      <h2 class="decorated-heading third">Terraform configuration</h2>

      <ul class="key-points">
        <li>
          <strong>State Management:</strong>
          Auto-generated Amplify resources must be
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/blob/8bd8208146607a8b47409129b409f46be5307b93/main.tf#L51-L70"
            target="_blank"
          >imported</a>
          into Terraform state for consistent infrastructure management.
        </li>
        <li>
          <strong>Custom Headers:</strong>
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/blob/8bd8208146607a8b47409129b409f46be5307b93/infrastructure/amplify/main.tf#L2"
            target="_blank"
          >Implemented</a>
          using <code>templatefile</code> function to insert
          <a rel="noreferrer" href="https://github.com/rgant/rob.gant.ninja/blob/main/scripts/set-csp-header.ts" target="_blank">dynamic</a>
          <abbr title="Subresource Integrity">SRI</abbr> hashes.
        </li>
        <li>
          <strong>Custom Domains:</strong>
          Managed through <code>aws_amplify_domain_association</code>
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/blob/8bd8208146607a8b47409129b409f46be5307b93/infrastructure/amplify/main.tf#L54"
            target="_blank"
          >resource</a>
          with additional Route53 configuration.
        </li>
      </ul>

      <div class="description">
        <p>
          The Terraform
          <a rel="noreferrer" href="https://github.com/rgant/rob.gant.ninja/tree/main/infrastructure" target="_blank"
          >configuration for the website</a>
          consists of modular components that handle different aspects of the AWS infrastructure. The Amplify module includes resources for
          the Amplify app itself, branch configuration, domain association, and custom headers. Additional modules manage supporting
          infrastructure like S3 buckets for deployment artifacts and DNS configuration. Terraform state is stored
          <a rel="noreferrer" href="https://github.com/rgant/rob.gant.ninja/tree/main/infrastructure/remote-config" target="_blank"
          >remotely in an S3 bucket</a>.
        </p>

        <p>
          One complexity with Amplify is that it automatically creates several sub-resources, only some of which are directly accessible
          through Terraform. For example, Amplify automatically generates DNS records for domain verification, which must be imported into
          the Terraform state to ensure consistent management. This maintains the infrastructure-as-code approach while working within
          Amplify’s architectural constraints. Although Amplify uses
          <a
            rel="noreferrer"
            href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/website-hosting-amplify.html#:~:text=globally%20available%20content%20delivery%20network%20(CDN)%20powered%20by%20Amazon%20CloudFront"
            target="_blank"
          >CloudFront</a>
          internally, it does not expose CloudFront configuration options. The default CloudFront configuration appears adequate for basic
          security requirements, though detailed security analysis remains pending.
        </p>

        <p>
          I implemented custom headers, including Content Security Policy with SRI hashes, using Terraform’s <code>templatefile</code>
          function to insert dynamic values into a <abbr title="YAML Ain’t Markup Language">YAML</abbr> configuration. This allows the
          security headers to be updated with each deployment while keeping the configuration declarative and version-controlled. As part of
          the build process, Astro exports the integrity hashes as a
          <a rel="noreferrer" href="https://www.typescriptlang.org/" target="_blank">TypeScript</a> file. Since
          <a rel="noreferrer" href="https://github.com/kindspells/astro-shield" target="_blank">@kindspells/astro-shield</a>
          does not provide direct <abbr title="JavaScript Object Notation">JSON</abbr> export functionality, I added a <code
          >postbuild</code> script to the
          <a rel="noreferrer" href="https://www.npmjs.com/" target="_blank" title="Node Package Manager">npm</a>
          package configuration that automatically writes the hashes to a JSON file that Terraform can consume.
        </p>
      </div>

      <div class="section-nav">
        <a href="#article-nav" class="top-link" title="Back to navigation">Top</a>
      </div>
    </section>

    <section id="challenges" class="slide">
      <h2 class="decorated-heading fourth">Challenges and workarounds</h2>

      <ul class="key-points">
        <li>
          <strong>Terraform Provider Limitations:</strong>
          AWS Amplify’s rapid evolution outpaces Terraform provider capabilities.
        </li>
        <li>
          <strong>Domain Provisioning Issues:</strong>
          Amplify domain association enters <code>PENDING_VERIFICATION</code> state indefinitely, requiring resource deletion and
          recreation.
        </li>
        <li>
          <strong>Custom Headers Bug:</strong>
          Terraform always detects header changes due to provider issue
          <a rel="noreferrer" href="https://github.com/hashicorp/terraform-provider-aws/issues/34318" target="_blank">#34318</a>, requiring
          <a rel="noreferrer" href="https://github.com/rgant/rob.gant.ninja/blob/main/infrastructure/amplify.tf#L92-L114" target="_blank"
          >AWS CLI</a> workaround.
        </li>
        <li>
          <strong>Deploying to Amplify:</strong>
          Terraform lacks deployment resource support, requiring
          <a rel="noreferrer" href="https://aws.amazon.com/cli/" target="_blank">AWS CLI</a>
          <code>start-deployment</code> integration via <code>terraform_data</code>.
        </li>
      </ul>

      <div class="description">
        <p>
          Working with AWS Amplify through Terraform presented several challenges, primarily stemming from Amplify’s rapid feature evolution
          outpacing the Terraform provider’s capabilities. Domain provisioning failed repeatedly during initial setup and testing phases.
          Multiple deletion and recreation cycles were required before successful domain association, suggesting race conditions or
          incomplete state synchronization within Amplify’s domain verification process.
        </p>

        <p>
          The custom headers workaround using <code>ignore_changes</code> proved unreliable because it required manual intervention for
          legitimate updates. Switching to AWS <abbr title="Command-Line Interface">CLI</abbr> execution via <code>terraform_data</code>
          provides better automation while maintaining infrastructure-as-code principles. This approach worked better than alternatives like
          external deployment scripts or CI/CD pipeline integration, which would have introduced additional dependencies outside the
          Terraform workflow.
        </p>

        <p>
          Manual deployment triggering through Terraform keeps consistent with the infrastructure management approach while working around
          provider limitations. GitHub integration requires an additional tool in the process and managing webhook configurations. The
          current AWS CLI approach keeps deployment control within the same tool managing infrastructure state and configuration.
        </p>
      </div>

      <div class="section-nav">
        <a href="#article-nav" class="top-link" title="Back to navigation">Top</a>
      </div>
    </section>

    <section id="security" class="slide">
      <h2 class="decorated-heading fifth">Security considerations</h2>

      <ul class="key-points">
        <li>
          <strong>Content Security Policy (CSP):</strong>
          Implemented with
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/blob/8bd8208146607a8b47409129b409f46be5307b93/astro.config.ts#L61"
            target="_blank"
          >SRI hashes</a>
          for all scripts and stylesheets, with <code>default-src 'none'</code> baseline policy.
        </li>
        <li>
          <strong>Resource Separation:</strong>
          Disabled
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/blob/8bd8208146607a8b47409129b409f46be5307b93/astro.config.ts#L68-L69"
            target="_blank"
          >inline resources</a>
          to maintain security boundaries at minimal performance cost.
        </li>
        <li>
          <strong>Access Control:</strong>
          Configured
          <a rel="noreferrer" href="https://github.com/rgant/rob.gant.ninja/blob/main/infrastructure/s3-bucket/main.tf" target="_blank"
          >S3 bucket policies</a>
          and <abbr title="Identity and Access Management">IAM</abbr> roles with least privilege principles.
        </li>
        <li>
          <strong>SSL Management:</strong>
          Leveraged Amplify’s
          <a
            rel="noreferrer"
            href="https://github.com/rgant/rob.gant.ninja/blob/8bd8208146607a8b47409129b409f46be5307b93/infrastructure/amplify/dns.tf#L8-L26"
            target="_blank"
          >automated certificate provisioning</a>
          while maintaining infrastructure control through Terraform.
        </li>
      </ul>

      <div class="description">
        <p>
          The CSP approach was chosen over simpler alternatives because static sites still face injection risks through compromised CDNs or
          build tools. Available tooling for generating and managing CSP and SRI hashes requires improvement, but I automated as much of the
          process as possible to ensure consistent implementation without manual hash management.
        </p>

        <p>
          Security benefits outweigh minimal performance costs. Future iterations may explore selective inlining for non-executable
          resources.
        </p>

        <p>
          Access controls for supporting infrastructure follow least privilege principles, with S3 bucket policies and IAM roles configured
          to provide only the necessary permissions for deployment and operation. While IAM management through Terraform would be ideal,
          documentation for this approach is sparse and not commonly practiced. I plan to investigate comprehensive IAM management options
          for future infrastructure iterations.
        </p>

        <p>
          SSL certificate management is handled through Amplify’s automated provisioning, which creates and renews certificates through AWS
          Certificate Manager. While this automation reduces manual maintenance, the certificates are not tracked in Terraform state. I
          manage the DNS verification record by importing it into Terraform after Amplify creates it, but the actual certificates remain
          outside Terraform management.
        </p>
      </div>

      <div class="section-nav">
        <a href="#article-nav" class="top-link" title="Back to navigation">Top</a>
      </div>
    </section>

    <section id="process" class="slide">
      <h2 class="decorated-heading second">Deployment process</h2>

      <ul class="key-points">
        <li>
          <strong>Build Pipeline:</strong>
          <code>npm run build</code> generates optimized static assets with SRI hashes.
        </li>
        <li>
          <strong>Terraform Application:</strong>
          <code>npm run deploy</code> applies infrastructure changes including updated assets and CSP headers.
        </li>
        <li>
          <strong>S3 Staging:</strong>
          Distribution files are synchronized to S3 bucket before Amplify deployment due to Terraform provider limitations.
        </li>
        <li>
          <strong>Amplify Deployment:</strong>
          Terraform triggers deployment via AWS CLI <code>start-deployment</code> command when distribution files change.
        </li>
        <li>
          <strong>Amplify Response Headers:</strong>
          Terraform triggers updates via AWS CLI <code>update-app --custom-headers</code> when SRI hashes or template changes occur.
        </li>
      </ul>

      <div class="description">
        <p>
          The build process is handled by an <abbr title="Node Package Manager">npm</abbr> script, which invokes Astro’s build command to
          generate optimized static assets in the <code>dist/</code> folder. The <code>postbuild</code> npm script automatically calculates
          SRI hashes for all JavaScript and <abbr title="Cascading Style Sheets">CSS</abbr> files, which are recorded for later inclusion in
          the Content Security Policy headers.
        </p>

        <p>
          An npm script applies the Terraform configuration to update infrastructure as needed and deploys updated assets and headers. The
          process first synchronizes the generated static files to an S3 bucket, which serves as a staging area for deployment. Terraform
          then triggers Amplify to deploy content from this S3 bucket to the live environment and updates response headers if necessary.
        </p>

        <p>
          S3 staging exists because Terraform cannot directly deploy files to Amplify. Direct file upload to Amplify would require switching
          to GitHub integration or similar, which introduces additional complexity and external dependencies. The S3 approach maintains full
          control within the AWS ecosystem while working around provider limitations.
        </p>

        <p>
          The AWS CLI workaround for deployment triggers emerged from Terraform’s lack of deployment resource support. Alternative
          approaches like GitHub webhooks or CodePipeline would introduce external dependencies or additional AWS services. This approach
          keeps the deployment process contained within the existing Terraform workflow.
        </p>

        <p>
          Header updates require AWS CLI due to the previously mentioned Terraform provider bug that always detects header changes even when
          identical. A <code>terraform_data</code> resource tracks changes by hashing the rendered template, triggering updates only when
          SRI hashes or template content actually change. This approach proved more reliable than manually managing the Terraform
          <code>ignore_changes</code> lifecycle rule.
        </p>
      </div>

      <div class="section-nav">
        <a href="#article-nav" class="top-link" title="Back to navigation">Top</a>
      </div>
    </section>

    <section id="monitoring" class="slide">
      <h2 class="decorated-heading third">Monitoring and observability</h2>

      <ul class="key-points">
        <li>
          <strong>Amplify Console Metrics:</strong>
          Built-in deployment tracking, build success/failure visibility, and basic traffic analytics through the AWS Amplify console.
        </li>
        <li>
          <strong>Error Monitoring:</strong>
          Configurable Amplify Alerts for 4xx error rates, request count spikes, and deployment failures with
          <abbr title="Simple Notification Service">SNS</abbr> notifications.
        </li>
        <li>
          <strong>Certificate Monitoring:</strong>
          AWS Certificate Manager automatically handles renewal notifications and provides expiration alerts through CloudWatch events.
        </li>
        <li>
          <strong>Budget Alerts:</strong>
          Existing Terraform configuration includes
          <a rel="noreferrer" href="https://github.com/rgant/rob.gant.ninja/blob/main/infrastructure/budget.tf" target="_blank"
          >cost monitoring</a>
          to prevent unexpected billing charges.
        </li>
      </ul>

      <div class="description">
        <p>
          The monitoring approach uses AWS-native tools to avoid introducing additional dependencies or complex observability stacks for a
          static website. Third-party monitoring solutions like Datadog or New Relic would introduce unnecessary complexity and cost for the
          limited monitoring requirements of a personal website with predictable traffic patterns.
        </p>

        <p>
          Amplify and Budget alerts serve as an effective early warning system for infrastructure misconfigurations or unexpected traffic
          spikes that could result in billing surprises. This approach proved more practical than implementing detailed CloudWatch metrics
          for a low-traffic site where cost anomalies are often the first indicator of technical issues requiring attention.
        </p>
      </div>

      <div class="section-nav">
        <a href="#article-nav" class="top-link" title="Back to navigation">Top</a>
      </div>
    </section>

    <section id="future" class="slide">
      <h2 class="decorated-heading fourth">Future improvements</h2>

      <ul class="key-points">
        <li>
          <strong>Branch Understanding:</strong>
          Explore Amplify’s branch capabilities for potential development/production environment separation.
        </li>
        <li>
          <strong>Performance Monitoring:</strong>
          Implement CloudWatch <abbr title="Real User Monitoring">RUM</abbr> for client-side performance metrics and Core Web Vitals
          tracking.
        </li>
        <li>
          <strong>Advanced Alerting:</strong>
          Expand Amplify alerts to include deployment duration thresholds and geographic traffic pattern monitoring.
        </li>
        <li>
          <strong>Recovery Documentation:</strong>
          Document domain recovery procedures and infrastructure recreation processes from
          <a rel="noreferrer" href="https://git-scm.com/" target="_blank">Git</a>
          and Terraform state.
        </li>
        <li>
          <strong>Provider Monitoring:</strong>
          Track AWS provider updates to leverage improvements to Amplify support.
        </li>
      </ul>

      <div class="description">
        <p>
          While not currently leveraged, Amplify’s branch capabilities offer potential for separating development and production
          environments. Further exploration of this feature could enable more sophisticated deployment workflows with proper staging and
          testing before production releases.
        </p>

        <p>
          Performance monitoring improvements would focus on implementing CloudWatch RUM to gather client-side performance data including
          Core Web Vitals metrics. This would provide insights into real user experience across different devices and network conditions,
          helping identify optimization opportunities for page load times and interactive elements.
        </p>

        <p>
          Advanced alerting would build upon the current Amplify alerts configuration to include deployment duration monitoring and
          geographic traffic analysis. Recovery planning would focus on documentation rather than redundant infrastructure, including
          procedures for domain recovery scenarios and complete infrastructure recreation from Git repositories and Terraform state backups.
        </p>

        <p>
          Backup and disaster recovery planning would establish cross-region S3 replication for critical deployment artifacts and Terraform
          state files. This includes documenting recovery procedures for domain transfers, SSL certificate replacement, and infrastructure
          recreation from Terraform state backups. Enhanced observability would involve structured logging implementation and custom
          CloudWatch dashboards for monitoring deployment pipelines and infrastructure health metrics.
        </p>

        <p>
          Terraform’s AWS provider releases rapidly. I will be
          <a rel="noreferrer" href="https://github.com/hashicorp/terraform-provider-aws/releases" target="_blank"
          >monitoring the releases</a>
          to notice when new features or updates apply to my infrastructure and to ensure that I don’t fall behind.
        </p>
      </div>

      <div class="section-nav">
        <a href="#article-nav" class="top-link" title="Back to navigation">Top</a>
      </div>
    </section>

    <aside>
      <nav aria-labelledby="section-nav">
        <h3 id="section-nav" class="decorated-heading primary">Continue reading about my site</h3>
        <MySiteNav />
      </nav>
    </aside>
  </article>
</Structure>
