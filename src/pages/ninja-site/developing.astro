---
import BaseHead from '~/components/base-head.astro';
import Structure from '~/layouts/structure.astro';
import { unwrap } from '~/unwrap.util';

const description = unwrap`Developing with Astro and native Custom Elements for interactive features,
  implementing Progressive Web App capabilities, and integrating Content Security Policy with SRI hashes.`;
---
<Structure>
  <BaseHead description={description} slot="head" title="Developing with Astro and Web Components" />

  <header class="banner main-header">
    <div class="heading">
      <h1 id="top">Developing the website</h1>
      <p>Building interactive features with native web technologies</p>
    </div>

    <details>
      <summary id="related-nav">Related articles</summary>

      <nav aria-labelledby="related-nav">
        <ul>
          <li><a href="index.html">Building a modern secure static website</a></li>
          <li><a href="setup.html">Setup an Astro TypeScript SSG project</a></li>
          <li><a href="deploy.html">Deploying SSG websites with Terraform</a></li>
          <li><a href="lessons.html">What I learned developing this project</a></li>
        </ul>
      </nav>
    </details>
  </header>

  <article>
    <aside>
      <nav aria-label="Article Navigation">
        <ul>
          <li><a href="#components">Custom Elements architecture</a></li>
          <li><a href="#pwa">Progressive Web App integration</a></li>
          <li><a href="#security">Content Security Policy implementation</a></li>
          <li><a href="#environment">Development environment</a></li>
          <li><a href="#experience">Astro development experience</a></li>
          <li><a href="#decisions">Technical decision framework</a></li>
        </ul>
      </nav>
    </aside>

    <section aria-labelledby="components">
      <h2 id="components">Custom Elements architecture</h2>

      <ul class="key-points">
        <li>
          <strong>Web Components:</strong>
          I chose native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements">Custom Elements</a>
          over <a href="https://angular.dev/">Angular</a>/<a href="https://react.dev/">React</a>/<a href="https://vuejs.org/">Vue</a>
          because a small amount of code could accomplish the interactive goals without framework overhead.
        </li>
        <li>
          <strong>Career Experience Component:</strong>
          I implemented <a href="https://github.com/rgant/rob.gant.ninja/tree/main/src/components/career-experience"
          >progressive enhancement</a> that provides static dates in <abbr title="HyperText Markup Language">HTML</abbr> with dynamic
          updates via JavaScript.
        </li>
        <li>
          <strong>Scroll Navigation Component:</strong>
          Migrated from <a
            href="https://github.com/rgant/rob.gant.ninja/blob/a2f09756cfe1b357689677cf20c234e1354d95fc/src/js/index-scroll.js"
          >jQuery scroll events</a> to <a
            href="https://github.com/rgant/rob.gant.ninja/blob/main/src/components/scroll-navigation/scroll-navigation.component.ts"
          >Intersection Observer</a> for better performance and modern <abbr title="Application Programming Interface">API</abbr> usage.
        </li>
        <li>
          <strong>Intersection Observer Configuration:</strong>
          Used <code>rootMargin: '-20% 0px -80%'</code> which counterintuitively results a 1-pixel height observation area that ensures only
          one section can have <code>isIntersecting: true</code> at any time, preventing multiple navigation items from activating
          simultaneously. The -20% top margin positions the observation area about one-fifth down the viewport for smoother navigation
          transitions.
        </li>
        <li>
          <strong><abbr title="Document Object Model">DOM</abbr> Encapsulation:</strong>
          Custom Elements enable accessing navigation elements within component tags without requiring global IDs or unique classes.
        </li>
      </ul>

      <div class="description">
        <p>
          For a static website with minimal interactive requirements, JavaScript frameworks introduce unnecessary complexity and bundle
          size. Native Custom Elements work well enough while keeping the DOM and logic co-located, improving maintainability and reducing
          the complexity of managing framework-specific patterns for simple interactions.
        </p>

        <p>
          The career experience component uses progressive enhancement by serving static calculation in the initial HTML for non-JavaScript
          environments while automatically updating to current calculations when JavaScript executes. This approach ensures the content
          remains functional and informative regardless of JavaScript availability while providing enhanced accuracy when possible.
        </p>

        <p>
          The scroll navigation feature existed in the previous <a href="https://parceljs.org/">Parcel</a>-based website using
          <a href="https://jquery.com/">jQuery</a> scroll events. While scroll events weren’t actually problematic for this simple
          single-page site, migrating to Intersection Observer provided better performance characteristics and follows current practices.
          Typical Intersection Observer implementations for this type of feature watch for heading elements, but mine
          triggers on any part of the section content instead.
        </p>

        <p>
          Configuring the Intersection Observer required understanding that <code>rootMargin</code> syntax differs from
          <abbr title="Cascading Style Sheets">CSS</abbr> margin properties, where negative percentages shrink the root intersection area
          rather than expanding it. The fundamental problem with default Intersection Observer behavior for this case is that multiple
          sections can intersect simultaneously, making it impractical to identify which section should actually activate the corresponding
          navigation item. The solution ensures that only one section intersects at any time.
        </p>
      </div>
    </section>

    <section aria-labelledby="pwa">
      <h2 id="pwa">Progressive Web App integration</h2>

      <ul class="key-points">
        <li>
          <strong>Motivation:</strong>
          <a href="https://html5boilerplate.com/">HTML5 Boilerplate</a> includes a default <code>site.webmanifest</code> file, and research
          showed <abbr title="Progressive Web App">PWA</abbr> features are essentially free to implement with <a href="https://vite.dev/"
          >Vite</a> and <a href="https://github.com/GoogleChrome/workbox">Workbox</a> integration.
        </li>
        <li>
          <strong>Implementation:</strong>
          I used <a href="https://github.com/vite-pwa/astro">@vite-pwa/astro</a> with separate <a
            href="https://github.com/rgant/rob.gant.ninja/blob/main/webmanifest.json"
          ><code>webmanifest.json</code></a> to keep static configuration outside build files.
        </li>
        <li>
          <strong>Performance Benefits:</strong>
          Resource precaching improves loading times for multi-page navigation, though not critical for the original single-page
          architecture.
        </li>
        <li>
          <strong>Configuration Challenges:</strong>
          Required both <a href="https://vite-pwa-org.netlify.app/guide/">Vite PWA documentation</a> and
          <a href="https://developer.chrome.com/docs/workbox/">official Workbox docs</a> along with example configurations to understand
          option purposes.
        </li>
        <li>
          <strong>Integration Requirements:</strong>
          Resolved <a href="https://www.typescriptlang.org/">TypeScript</a> recognition by adding references to
          <a href="https://github.com/rgant/rob.gant.ninja/blob/main/src/env.d.ts"><code>env.d.ts</code></a> and configured script import in
          an <a href="https://github.com/rgant/rob.gant.ninja/blob/feature/ninja-site/src/components/end-scripts.astro"
          >EndScripts component</a>.
        </li>
      </ul>

      <div class="description">
        <p>
          The decision to implement PWA features came from learning that many developers consider them essentially free additions when using
          modern build tools. Since HTML5 Boilerplate had already included a manifest file that went unused, researching PWA implementation
          revealed minimal effort required for performance improvements.
        </p>

        <p>
          Workbox configuration required careful testing of build artifacts to ensure the precache list included necessary resources while
          excluding unnecessary ones. The <a href="https://github.com/vite-pwa/astro/tree/main/examples">vite-pwa examples</a> demonstrate
          practically every available option but lack clear explanations of individual option purposes, requiring me to check multiple
          documentation sources to understand the configuration impact.
        </p>

        <p>
          While PWA features aren’t required for basic static websites, they represent necessary infrastructure for modern web applications.
          Implementing them on a simple site provides familiarity with the tooling and patterns that will be essential for more complex
          projects requiring offline capabilities and enhanced performance characteristics.
        </p>
      </div>
    </section>

    <section aria-labelledby="security">
      <h2 id="security">Content Security Policy implementation</h2>

      <ul class="key-points">
        <li>
          <strong>Security Analysis Compliance:</strong>
          Implemented <abbr title="Content Security Policy">CSP</abbr> with <abbr title="Subresource Integrity">SRI</abbr> hashes based on
          recommendations from <a href="https://developer.mozilla.org/en-US/observatory/analyze?host=rob.gant.ninja">Mozilla Observatory</a>
          security analysis tools.
        </li>
        <li>
          <strong>Static Site Strategy:</strong>
          Chose SRI hashes over nonces because server-side code generation isn’t available for static sites, making SRI the most secure
          alternative approach.
        </li>
        <li>
          <strong>Implementation Tool:</strong>
          Used <a href="https://github.com/kindspells/astro-shield">@kindspells/astro-shield</a> for automatic SRI hash generation and
          integration with build process.
        </li>
        <li>
          <strong>Asset Inlining Decision:</strong>
          Disabled resource inlining (<code>assetsInlineLimit: 0</code>) based on security analysis recommendations, accepting minimal
          performance cost for security boundary benefits.
        </li>
        <li>
          <strong>Current Compromise:</strong>
          Using <code>script-src 'self'</code> as the only relaxed rule, with plans to evaluate removing <code>'self'</code> directive in
          future iterations.
        </li>
      </ul>

      <div class="description">
        <p>
          Security analysis tools and Angular’s improved support motivated the CSP implementation. Rather than implementing relaxed rules
          that provide minimal security benefits, the strict approach with SRI hashes provides meaningful protection against code injection
          attacks, even for static sites with limited server-side functionality.
        </p>

        <p>
          SRI hash integration was the primary technical challenge, specifically how to inject dynamically generated hashes into
          <abbr title="HyperText Transfer Protocol">HTTP</abbr> response headers managed by <a href="https://aws.amazon.com/amplify/"
          >AWS Amplify</a>. The @kindspells/astro-shield tool handles hash computation effectively, but requires custom scripting to
          export hashes in <abbr title="JavaScript Object Notation">JSON</abbr> format for
          <a href="https://developer.hashicorp.com/terraform">Terraform</a> consumption, as detailed in the <a href="deploy.html"
          >deployment</a> process.
        </p>

        <p>
          Disabling asset inlining eliminates potential security vulnerabilities where inline resources could bypass CSP restrictions. The
          performance cost of additional HTTP requests proved negligible compared to the security boundary benefits, particularly when
          pursuing comprehensive security analysis tool compliance. The goal of achieving clean security reports from analysis tools
          justified the trade-off between minimal performance costs and enhanced security posture.
        </p>

        <p>
          Future improvements will explore <a href="https://docs.astro.build/en/reference/experimental-flags/csp/"
          >Astro’s experimental CSP features</a> currently in beta and evaluate whether the <code>'self'</code> directive can be removed
          entirely while maintaining functionality. The current CSP configuration provides a solid foundation for expansion as the site
          grows in complexity.
        </p>
      </div>
    </section>

    <section aria-labelledby="environment">
      <h2 id="environment">Development environment</h2>

      <ul class="key-points">
        <li>
          <strong>Editor Choice:</strong>
          Configured <a href="https://www.sublimetext.com/">Sublime Text</a> with linting and <abbr title="Language Server Protocol"
          >LSP</abbr> packages for code quality enforcement during development.
        </li>
        <li>
          <strong>Configuration Reference:</strong>
          Sublime Text configuration available at <a
            href="https://github.com/rgant/homedir/tree/main/Library/Application-Support/Sublime-Text-3/Packages/User"
          >GitHub User Package repository</a> for interested developers.
        </li>
      </ul>

      <div class="description">
        <p>
          While most developers use <a href="https://code.visualstudio.com/" title="Visual Studio Code">VSCode</a>, Sublime Text remains a
          viable option with proper LSP and linting integration. The configuration provides real-time feedback for TypeScript,
          <a href="https://eslint.org/">ESLint</a>, and <a href="https://stylelint.io/">Stylelint</a> rules, ensuring code quality standards
          are maintained throughout the development process. Since this represents a minority editor choice, detailed configuration
          explanation would benefit few readers compared to linking to the complete setup for those specifically interested in Sublime Text
          workflows.
        </p>
      </div>
    </section>

    <section aria-labelledby="experience">
      <h2 id="experience">Astro development experience</h2>

      <ul class="key-points">
        <li>
          <strong>TypeScript Integration:</strong>
          <a href="https://astro.build/">Astro</a>’s native TypeScript support provides excellent developer experience without additional
          configuration complexity.
        </li>
        <li>
          <strong>Build Process Coordination:</strong>
          Tool integration requires attention to execution order, ensuring SRI hash computation occurs after compression and PWA generation.
        </li>
        <li>
          <strong>Development Server:</strong>
          Vite-powered development server provides fast hot reload and developer experience improvements.
        </li>
        <li>
          <strong>Astro Islands Limitation:</strong>
          Islands architecture only supports <abbr title="Single Page Application">SPA</abbr> frameworks like React and Vue, not native
          Custom Elements integration.
        </li>
      </ul>

      <div class="description">
        <p>
          Astro’s TypeScript-first approach eliminates the configuration overhead typically associated with adding TypeScript to JavaScript
          frameworks. The build process integration between multiple tools requires minimal coordination beyond ensuring SRI hash
          computation happens after all asset optimization and PWA manifest generation completes.
        </p>

        <p>
          The Vite development server provides better performance than previous build tool experiences, explaining why frameworks like
          Angular are migrating to Vite-based development servers. The hot reload functionality works reliably with the TypeScript and
          Custom Elements combination without requiring special configuration.
        </p>

        <p>
          While Astro Islands provide powerful partial hydration capabilities for framework components, the lack of direct Custom Elements
          support represents a missed opportunity for developers preferring native web technologies over framework dependencies. This
          limitation doesn’t affect functionality but prevents leveraging Astro’s selective hydration optimizations for Custom Elements.
        </p>
      </div>
    </section>

    <section aria-labelledby="decisions">
      <h2 id="decisions">Technical decision framework</h2>

      <ul class="key-points">
        <li>
          <strong>Tool Selection Criteria:</strong>
          Prioritize identifying the correct tool for specific job requirements rather than using familiar tools regardless of fit.
        </li>
        <li>
          <strong>Framework vs Native Choice:</strong>
          Astro and Custom Elements proved correct for static site requirements compared to React and
          <abbr title="Server-Side Rendering">SSR</abbr> alternatives.
        </li>
        <li>
          <strong>Security vs Performance Trade-offs:</strong>
          Default to security when faced with trade-offs, trusting that performance improvements occur over time while security typically
          degrades without active maintenance.
        </li>
        <li>
          <strong>Optimal Strategy:</strong>
          Pursue both security and performance when possible, accepting trade-offs only when genuine conflicts exist between requirements.
        </li>
      </ul>

      <div class="description">
        <p>
          The framework selection process shows why of matching tools to specific requirements rather than defaulting to popular choices.
          For a static site with minimal interactivity, Custom Elements works well enough without the overhead and complexity of larger
          frameworks designed for complex application state management.
        </p>

        <p>
          The security-first approach when facing trade-offs reflects the reality that performance optimizations continue improving through
          tool updates and hardware advancement, while security posture tends to degrade over time without active maintenance. This
          perspective influenced decisions like disabling asset inlining and implementing strict CSP policies despite minimal performance
          costs.
        </p>

        <p>
          When genuine conflicts between security and performance requirements don’t exist, pursuing both objectives simultaneously produces
          superior outcomes. The PWA implementation demonstrates this approach by providing both security benefits through manifest
          configuration and performance improvements through resource precaching without compromising either objective.
        </p>
      </div>
    </section>
  </article>
</Structure>
