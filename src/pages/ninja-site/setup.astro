---
import BaseHead from '~/components/base-head.astro';
import Structure from '~/layouts/structure.astro';
import { unwrap } from '~/unwrap.util';

const description = unwrap`Setting up an Astro TypeScript static site generator project with strict
  linting, modular Terraform infrastructure, and organized development workflow.`;
---
<Structure>
  <BaseHead description={description} slot="head" title="Setup an Astro TypeScript SSG Project" />

  <header class="banner main-header">
    <div class="heading">
      <h1 id="top">Project setup and structure</h1>
      <p>Starting out with an organized development workflow</p>
    </div>

    <details>
      <summary id="related-nav">Related articles</summary>

      <nav aria-labelledby="related-nav">
        <ul>
          <li><a href="index.html">Building a modern secure static website</a></li>
          <li><a href="developing.html">Developing with Astro and Web Components</a></li>
          <li><a href="deploy.html">Deploying SSG websites with Terraform</a></li>
          <li><a href="lessons.html">What I learned developing this project</a></li>
        </ul>
      </nav>
    </details>
  </header>

  <article>
    <aside>
      <nav aria-label="Article Navigation">
        <ul>
          <li><a href="#environment">Development environment</a></li>
          <li><a href="#dependencies">Dependency management</a></li>
          <li><a href="#migration">Framework migration</a></li>
          <li><a href="#configuration">Build process configuration</a></li>
          <li><a href="#infrastructure">Infrastructure organization</a></li>
          <li><a href="#challenges">Setup challenges</a></li>
          <li><a href="#future">Future improvements</a></li>
        </ul>
      </nav>
    </aside>

    <section aria-labelledby="environment">
      <h2 id="environment">Development environment</h2>

      <ul class="key-points">
        <li>
          <strong>Language Version Management:</strong>
          I use <a href="https://github.com/nvm-sh/nvm" title="Node Version Manager">nvm</a> for <a href="https://nodejs.org/en">Node.js</a>
          version management when working across multiple projects with different requirements.
        </li>
        <li>
          <strong>Package Manager Choice:</strong>
          <a href="https://www.npmjs.com/" title="Node Package Manager">npm</a> works well enough as the default Node.js package manager,
          with <a href="https://github.com/nodejs/corepack">Corepack</a> enabling cross-project compatibility.
        </li>
        <li>
          <strong>Editor Configuration:</strong>
          Configuring linters, <abbr title="Language Server Protocol">LSP</abbr> servers, and formatters improve development efficiency.
          Try out <abbr title="Large Language Model">LLM</abbr> assistants to see if you find them helpful.
        </li>
        <li>
          <strong>Configuration Documentation:</strong>
          I comment configuration files and linking to source configurations for future reference and updates.
        </li>
      </ul>

      <div class="description">
        <p>
          Language version management tools like <abbr title="Node Version Manager">nvm</abbr> are essential when working across multiple
          projects with different version requirements. I use <abbr title="Node Package Manager">npm</abbr> because it’s the default package
          manager that comes with Node.js, though other package managers work equally well. Corepack ensures access to the appropriate
          package manager for each codebase regardless of personal preference. Although npm will not include Corepack by default, it will
          remain available as a separate installation for cross-project package manager compatibility.
        </p>

        <p>
          Editor setup improves development efficiency. Prioritize linter integration for code quality, LSP for type checking and
          autocomplete, and formatters for consistency. While automatic formatting helps maintain consistency, manual formatting control
          often produces cleaner results.
        </p>
      </div>
    </section>

    <section aria-labelledby="dependencies">
      <h2 id="dependencies">Dependency management</h2>

      <ul class="key-points">
        <li>
          <strong>Version Range Management:</strong>
          Follow framework template conventions for version ranges before implementing custom policies. Generally tilde ranges
          (<code>~1.2.4</code>) for production dependencies and caret ranges (<code>^1.3.2</code>) for <code>devDependencies</code>, but
          since this project runs entirely locally, minor release flexibility provides better security updates without deployment risk.
        </li>
        <li>
          <strong>Dependency Locking:</strong>
          I recommend locking dependency versions and committing lock files to ensure reproducible builds across environments. Organize
          dependencies between production (necessary for the primary goal) and development (workflow tools like linters and compilers), with
          <code>devDependencies</code> accepting more frequent updates in <code>package.json</code>.
        </li>
        <li>
          <strong>Cross-Platform Compatibility:</strong>
          I encountered compatibility issues between development and deployment environments. Windows vs. Linux can often need separate
          dependencies even in straightforward projects.
        </li>
      </ul>

      <div class="description">
        <p>
          Dependency locking prevents unexpected version changes that can break builds or introduce inconsistencies between team members.
          For web applications or sites, I categorize dependencies as production (necessary for building the website) versus development
          (linters, compilers, and development tools). Development dependencies can accept more frequent updates in version range specifiers
          since they don’t affect the final build output.
        </p>

        <p>
          Regular dependency updates should be routine rather than intimidating when combined with strict code quality enforcement and
          automated testing that catch regressions early. Cross-platform compatibility awareness helps avoid deployment surprises,
          particularly between Unix-like development environments and different production platforms. Version range management requires
          balancing stability with security updates, especially for development tools that change rapidly.
        </p>

        <p>
          Cross-platform compatibility awareness helps avoid deployment surprises, particularly between Unix-like development environments
          and different production platforms.
        </p>
      </div>
    </section>

    <section aria-labelledby="migration">
      <h2 id="migration">Framework migration</h2>

      <ul class="key-points">
        <li>
          <strong>Build Framework Migration:</strong>
          I replaced <a href="https://parceljs.org/">Parcel</a> with <a href="https://astro.build/">Astro</a> to leverage its
          <abbr title="Static Site Generation">SSG</abbr>-focused architecture and optimizations.
        </li>
        <li>
          <strong>Template Foundation:</strong>
          Starting with Astro’s <a href="https://github.com/withastro/astro/tree/main/examples/blog">blog template</a> provided a solid
          foundation.
        </li>
        <li>
          <strong>Custom Plugin Elimination:</strong>
          The migration eliminated <a href="https://github.com/rgant/rob.gant.ninja/tree/a2f09756cfe1b357689677cf20c234e1354d95fc/packages"
          >custom plugins</a> that were required by Parcel for SSG functionality.
        </li>
      </ul>

      <div class="description">
        <p>
          The project began as a Parcel-based static site that required custom plugins to achieve static site generation capabilities. Astro
          treats static sites as first-class rather than an afterthought, eliminating the need for custom plugin development while providing
          built-in SSG optimizations and better performance.
        </p>

        <p>
          Starting with Astro’s blog template and strict <a href="https://www.typescriptlang.org/">TypeScript</a> configuration provided
          essential configurations for TypeScript, build processes, and development server setup that accelerated initial project setup.
        </p>
      </div>
    </section>

    <section aria-labelledby="configuration">
      <h2 id="configuration">Build process configuration</h2>

      <ul class="key-points">
        <li>
          <strong>Security:</strong>
          I implemented <a href="https://github.com/kindspells/astro-shield">@kindspells/astro-shield</a> for
          <abbr title="Subresource Integrity">SRI</abbr> hash generation in <abbr title="Content Security Policy">CSP</abbr> headers.
        </li>
        <li>
          <strong>Optimizations:</strong>
          I use <a href="https://github.com/playform/compress">@playform/compress</a> for asset minification, although it has
          outdated dependencies requiring workarounds.
        </li>
        <li>
          <strong>Performance:</strong>
          I integrated <a href="https://github.com/vite-pwa/astro">@vite-pwa/astro</a> for resource precaching and offline
          capabilities.
        </li>
        <li>
          <strong>Configuration Strictness:</strong>
          I established strict <a href="https://github.com/rgant/rob.gant.ninja/blob/main/tsconfig.json">TypeScript</a>,
          <a href="https://github.com/rgant/rob.gant.ninja/blob/main/eslint.config.ts">ESLint</a>, and
          <a href="https://github.com/rgant/rob.gant.ninja/blob/main/.stylelintrc.json">Stylelint</a> configurations.
        </li>
      </ul>

      <div class="description">
        <p>
          I prioritized security then performance because they are vital requirements for modern web projects. @kindspells/astro-shield
          provides essential security headers with SRI hashes, while @vite-pwa/astro delivers performance benefits through resource
          precaching that benefit even static sites.
        </p>

        <p>
          @playform/compress handles asset optimization but relies on outdated tools like <a href="https://github.com/css/csso">csso</a>
          (conflicts with modern <abbr title="Cascading Style Sheets">CSS</abbr>) and
          <a href="https://github.com/terser/html-minifier-terser">html-minifier-terser</a> (unmaintained).
          Manual optimization documented in <a href="https://github.com/rgant/rob.gant.ninja/blob/main/docs/optimizing-svgs.md"><code
          >optimizing-svgs.md</code></a> addresses limitations with CSS background-image compression.
        </p>

        <p>
          Strict configurations were carefully researched to incorporate established best practices and recently maintained plugins. The
          research process involved examining multiple configuration examples, plugin documentation, and community discussions to understand
          the implications of different rule sets. Configuration conflicts between tools required careful resolution to maintain both code
          quality and development efficiency. Some plugins required custom configuration due to project-specific requirements or
          compatibility issues with other tools in the development stack.
        </p>
      </div>
    </section>

    <section aria-labelledby="infrastructure">
      <h2 id="infrastructure">Infrastructure organization</h2>

      <ul class="key-points">
        <li>
          <strong>Modular Structure:</strong>
          I organized <a href="https://developer.hashicorp.com/terraform">Terraform</a> configuration into reusable
          <a href="https://github.com/rgant/rob.gant.ninja/tree/main/infrastructure/amplify">modules</a> for better maintainability.
        </li>
        <li>
          <strong>Single Entry Point:</strong>
          Creating <a href="https://github.com/rgant/rob.gant.ninja/blob/main/main.tf">main.tf</a> as a single entry point helps eliminate
          project root clutter.
        </li>
        <li>
          <strong>Component Organization:</strong>
          I recommend separating infrastructure into logical modules for <a href="https://aws.amazon.com/amplify/">AWS Amplify</a>,
          <a href="https://aws.amazon.com/s3/" title="AWS S3">S3</a> buckets, <abbr title="Domain Name System">DNS</abbr>, and remote state
          management.
        </li>
      </ul>

      <div class="description">
        <p>
          The Terraform configuration consists of modular components handling different
          <a href="https://aws.amazon.com/" title="Amazon Web Services">AWS</a> infrastructure aspects. The Amplify module includes
          resources for the app, branch configuration, domain association, and custom headers. Additional modules manage S3 buckets, DNS
          configuration, and remote state storage.
        </p>

        <p>
          Directory organization eliminated project root clutter that made it difficult to locate important files among numerous
          configuration files. Terraform modules organize components into well-known locations for easier navigation during maintenance and
          updates.
        </p>
      </div>
    </section>

    <section aria-labelledby="challenges">
      <h2 id="challenges">Setup challenges</h2>

      <ul class="key-points">
        <li>
          <strong>Environment Variable Management:</strong>
          I created a <a href="https://github.com/rgant/rob.gant.ninja/blob/main/.auto.tfvars.example"><code>.auto.tfvars.example</code></a>
          pattern for Terraform variables while excluding actual values from version control.
        </li>
        <li>
          <strong>Astro Configuration Compatibility:</strong>
          Resolving <a href="https://github.com/rgant/rob.gant.ninja/blob/main/src/env.d.ts"><code>env.d.ts</code></a> requirements for
          @vite-pwa/astro required research because Astro no longer adds this file in the starter template.
        </li>
        <li>
          <strong>Documentation Structure:</strong>
          I established a dedicated <a href="https://github.com/rgant/rob.gant.ninja/tree/main/docs">documentation directory</a>
          which can also be used for eventual GitHub Pages documentation website.
        </li>
      </ul>

      <div class="description">
        <p>
          Environment variable management required research to determine appropriate patterns for both Terraform and Astro configurations.
          The <code>.auto.tfvars.example</code> pattern provides template guidance while maintaining security by excluding actual values
          from version control. Terraform automatically includes <code>.auto.tfvars</code> file when running commands, making this a
          convenient pattern for local configuration.
        </p>

        <p>
          <abbr title="Progressive Web App">PWA</abbr> integration presented compatibility challenges as Astro moves away from
          <code>env.d.ts</code> while @vite-pwa/astro still requires it. Resolving this required consulting documentation from
          both projects to ensure long-term compatibility and support.
        </p>

        <p>
          The docs directory follows GitHub Pages patterns, providing a convenient location for documentation that doesn’t clutter the
          project root.
        </p>
      </div>
    </section>

    <section aria-labelledby="future">
      <h2 id="future">Future improvements</h2>

      <ul class="key-points">
        <li>
          <strong>Development Environment Modernization:</strong>
          I’m considering <a href="https://devenv.sh/">devenv.sh</a> for comprehensive development environment management, though potential
          workflow changes require careful evaluation.
        </li>
        <li>
          <strong>Automated Formatting Integration:</strong>
          Worth exploring <a href="https://github.com/lint-staged/lint-staged">lint-staged</a> to automatically format files before commit,
          improving consistency without manual intervention.
        </li>
        <li>
          <strong>Build Tool Replacement:</strong>
          I plan to replace @playform/compress with modern alternatives that support CSS background-image optimization and maintained
          <abbr title="HyperText Markup Language">HTML</abbr> minification. Worth evaluating
          <a href="https://github.com/j9t/html-minifier-next">html-minifier-next</a> though changes appear limited to updated dependencies
          rather than new features.
        </li>
        <li>
          <strong>Direct Vite Integration:</strong>
          Evaluating a switch to direct <a href="https://github.com/parcel-bundler/lightningcss">lightningcss</a> integration through
          <a href="https://vite.dev/">Vite</a> for better CSS processing and fewer dependency layers.
        </li>
        <li>
          <strong>Plugin Modernization:</strong>
          I continue periodic evaluation of older plugins for actively maintained alternatives with better feature sets.
        </li>
      </ul>

      <div class="description">
        <p>
          Development environment management could benefit from more comprehensive tooling like devenv.sh, though such changes require
          careful consideration of workflow disruption versus benefits. Similarly, automated formatting through lint-staged could reduce
          manual formatting effort while maintaining code consistency.
        </p>

        <p>
          The current build optimization stack has maintenance challenges with outdated dependencies like csso and html-minifier-terser.
          Finding modern replacements that handle CSS background-image optimization and reliable HTML minification would eliminate these
          technical debt concerns. html-minifier-next appears to primarily offer updated dependencies rather than substantial feature
          improvements.
        </p>

        <p>
          Direct Vite integration for CSS processing through lightningcss could simplify the build pipeline and provide better CSS
          optimization. Ongoing plugin evaluation ensures the project benefits from community improvements while avoiding abandoned or
          problematic dependencies.
        </p>
      </div>
    </section>
  </article>
</Structure>
